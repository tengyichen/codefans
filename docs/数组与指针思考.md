# char \*a, char b[10]和char (\*c)\[10\]
######By Lulin_W

标题给出了三个变量定义，他们的含义分别为：

	char *a;			// 指向char类型的指针  
	char b[10];			// char类型数组，元素个数为10
	char (*c)[10];		// 指向元素个数为10的char型数组的指针
	
存在下列合法赋值（对合法的定义是指gcc编译无告警不报错，下同）：

	a = b;
	c = b;
	
下面的赋值语句都不合法：

	a = c;				// X
	c = a;				// X
	
	char (*d)[5];
	char e[5];
	c = d;				// X
	c = e;				// X
	
	
一个不很严谨的解释如下：

	a = b;	// 合法。指针a的步长和数组b的第一维长度相等，指针指向的内容和数组第一维元素类型相同
	c = b;	// 合法。如果语句换成c = &b更好理解一些，指针c是指向数组的指针，b的值恰好为这个类型数组的一个入口。
			// c语言中，对数组变量而言，取地址运算等于数组变量本身。
			
	a = c;	// 非法。指针a和指针c所指向数据的类型不同，他们的步长不同。
	c = a;	// 非法。同上。
	c = d;	// 非法。同上。
	c = e;	// 非法。指针a指向的数据类型，和数组e的类型不一致。两种类型的长度不一样。
	
我们习惯了用a表示b，但是c才是为数组a量体裁衣的指针。不过我们很少用c的表示法。例如有下列函数原型：

	/*
	 * 参数p表示char型指针，len表示其长度。
	 * 风格良好。
	 */
	int funcA(char *p, size_t len);
	
	/*
	 * 很明确，参数n表示一个数组指针。
	 * 这种用法似乎很少见。Right but not practical.
	 */
	int funcB(char (n*)[10]);
	
	/*
	 * 参数x一般指一个int型变量的地址。而最好不要用来表示一段长度为int的连续内存。
	 * 表示连续内存的用法，有些程序员用过，libc里甚至都有这种例子(exec函数族)。
	 */
	int funcC(int *x);
	
留个悬念：

	char f[2][10];
	c = f;				// 合法吗？
	
本文完。
